魔法师小树有n个魔法元素，他把它们排成-行，从左到右第1个魔法元素的能量值是一个非
零整数ajo小树每次施展竟法的方式是挑选一段连续非空的魔法元素， 将它们的能量值乘起
来，得到值就是这次魔法的总能量。如果总能量大于零即为白魔法，否则为黑魔法。
现在小树想知道施展一个白魔法或黑魔法的方案数分别有多少。 两个方案不同是指挑选的连
续区间不同。
输入描述
第一行有一个整数n(1≤n≤2*105 ).表示魔法元素的个数。
第二行有n个整数(2....n (-109 ≤aj≤109;a;≠0) 代表魔法元素的能
量值。
输出描述
输出两个整数，分别表示施展一个黑魔法和施展一个白魔法的方案数


n = int(input())
customers = {}
priority_queue = []
for i in range(n):
    op, *args = input().split()
    if op == 'a':
        num, priority = map(int, args)
        if priority not in customers:
            customers[priority] = []
        customers[priority].append(num)
    else:
        while not priority_queue:
            priority = min(customers)
            priority_queue = customers.pop(priority)
        print(priority_queue.pop(0))
        if priority_queue:
            customers[priority] = priority_queue
            priority_queue = []
首先，输入第一个整数n，表示事件数量。然后，我们使用一个字典来保存每个优先级的客户列表。对于每个到来的客户，我们将其添加到相应优先级的客户列表中。对于每个银行办理业务的事件，我们按优先级从低到高遍历客户字典，并将优先级最高的客户列表添加到优先级队列中。我们然后打印队列中的第一个客户，并将剩余客户重新添加到字典中，以便以后处理。





Question Description
Problem Statement
Booking.com uses a 3rd party provider in order to convert from the user's currency to the actual currency listed by the partner/hotel. For
example, our user may use Euro while booking a hotel in GB, Booking.com will eventually pay in GBP to the partner.
Our currency conversion provider only has a f
currency conversion options available. We need to check if currency conversion is Rate
possible from the partner's currency to the currency mentioned by the user or not.
If the conversion is possible, we need to return the hotel price in the user's currency.		
If the conversion is not possible, we need to return -1.
Booking also charges a service fee to the users for every exchange conversion.
Booking calculates service fee by charging X(variable input) for every vendor side transaction.
If Booking does K vendor transactions for user exchange then service fee will be X*K of user currency. Calculate total price of conversion for the user.
The service fee needs to be added to the price in	In	

/**

给定一个字符串 s,  里面包括 '('，')'，'{'，'}'，'['，']' ，判断字符串是否有效。





有效字符串需满足：





* 左括号必须用相同类型的右括号闭合。

* 左括号必须以正确的顺序闭合。

* {, [ ( 必须按照  先{,  再[, 再 (的顺序,   如果有 { 里面就必须有 [, 有[ 里面就必须有(





示例 1：

输入：s = "(a)"

输出：true



示例 2：

输入：s = "a()[]{}"

输出：false



示例 3：

输入：s = "{[(a)(b)]}"

输出：true



示例 4：

输入：s = "{[]()]"

输出：false



示例 5：

输入：s = "(a[b])"

输出：false



示例 6：

输入：s = "{a[b]}"

输出：false



示例 7：

输入：s = "[a(b)]"

输出：true



示例 8：

输入：s = "a"

输出：true



示例 9：

输入：s = "{a}"

输出：false



示例 10：

输入：s = "((a))"

输出：false



示例 11：

输入：s = "[()[()]]"

输出：false



示例 12：

输入：s = "[[()]()]"

输出：false

*/





public boolean isValidCharacter(String s){

		if(s.length()%2!=0){

			return false;

		}

		

		

		Map<Character,Character> validPairs=new HashMap<Character,Character>();

			validPairs.put('}', '{');

			validPairs.put(']', '[');

			validPairs.put(')', '(');



		Deque<Character> stack=new LinkedList<Character>();

		

		for(int i=0;i<s.length();i++){

			char ch=s.charAt(i);

			if()

			if(validPairs.containsKey(ch)){

				if(stack.isEmpty()){

					return false;

				}

				char tmp=validPairs.get(ch);

				char top=stack.peek();

				if(tmp!=top){

					return false;

				}

				

				stack.pop();

			}else{

				stack.push(ch);

			}

		}

		return stack.isEmpty();

		

	}

/**

我们需要帮助员工在亚马逊找mentor。这个mentor需要在员工的 4 层好友中寻找到相同职位，职级更高的员工。

我们有一个API getFriends（Emp employee） 会回一个好友列表 (list). 这个列表就是员工的1 层好友。

朋友的朋友是2层好友。



// We are working on an application that helps find mentors for Amazon employees. 

// We want to make recommendations for people that are within 4 (N) degrees of an employee's circle of friends. 

// mentors have the same role and are more senior than the requested employee. 

// We are given an API call to get the information about friends for an employee.



// Write a method that will take an Employee and return a list of IDs of recommended mentors.



/**

 * This call is provided to you.

 * Returns only the other employees immediately known to the given employee

 */

List<Emp> getFriends(Emp employee);  





class Emp {

  long id;

  String name;

  String title; // This will match across employees with the same job.

  int level; // A higher number means more senior

}



// Method to implement

List<Emp> getSuggestedMentors(Emp loggedIn);







public List<Emp> getSuggestedMentors(Emp loggedIn){

	List<Emp> firstLevel=getFriends(loggedIn);

	List<Emp> secondLevel=getFriends(firstLevel);

	List<Emp> thirdLevel=getFriends(secondLevel);

	List<Emp> fourthLevel=getFriends(thirdLevel);



	List<Emp> mentorList=new ArrayList<Emp>();

	List<Emp> result=new ArrayList<>();

	List<Emp> firstLevelMentor=getMentor(getFriends(loggedIn));

	List<Emp> sencondLevelMentor=getMentor(getFriends(firstLevel),loggedIn));

	List<Emp> thirdLevelMentor=getMentor(getFriends(secondLevel),loggedIn));

	List<Emp> fourthLevelMentor=getMentor(getFriends(thirdLevelMentor),loggedIn));

	

	

	result.addAll(fourthLevelMentor);



	return result;

	

}

public List<Emp> getMentor(List<Emp> friendList,Emp loggedIn){

	List<Emp> mentorList=new ArrayList<Emp>();

	for(Emp employee:friendList){

	if(employee.level >loggedIn.level){

		mentorList.add(employee);

	}

	}

	return mentorList;	

}

*/

