class Solution:
    def findLowestCommonAncestor(self, root, p1, p2):
        # 使用递归方式搜索两个分支的最小公共祖先
        # 如果当前节点是None或者等于p1或p2，则直接返回当前节点
        if not root or root == p1 or root == p2:
            return root

        # 在左子树中递归搜索p1和p2的最小公共祖先
        left = self.findLowestCommonAncestor(root.left, p1, p2)
        # 在右子树中递归搜索p1和p2的最小公共祖先
        right = self.findLowestCommonAncestor(root.right, p1, p2)

        # 如果在左子树和右子树中都找到了非None的节点，那么当前节点就是最小公共祖先
        if left and right:
            return root

        # 如果只在其中一个子树中找到非None节点，则返回该节点
        return left if left else right


class CommitNode:
    def __init__(self, commitHash):
        self.commitHash = commitHash
        self.left = None
        self.right = None

# 创建一个版本控制系统的示例二叉树
#        C1
#       / \
#      C2  C3
#     /  \
#   C4    C5
# 假设C1是根节点，每个节点代表一个提交，有唯一的哈希值和父节点指针
C1 = CommitNode("C1")
C2 = CommitNode("C2")
C3 = CommitNode("C3")
C4 = CommitNode("C4")
C5 = CommitNode("C5")

C1.left = C2
C1.right = C3
C2.left = C4
C2.right = C5

# 创建Solution对象
solution = Solution()

# 在示例二叉树中寻找C4和C5的最小公共祖先
lowest_common_ancestor = solution.findLowestCommonAncestor(C1, C4, C5)

# 输出最小公共祖先的哈希值
print("最小公共祖先的哈希值:", lowest_common_ancestor.commitHash)

代码思路：
这段代码实现了一个名为Solution的类，其中包含一个方法findLowestCommonAncestor用于寻找两个提交节点的最小公共祖先。我们还定义了一个名为CommitNode的类，表示二叉树中的提交节点，每个节点有唯一的哈希值和左右子节点。

代码中的findLowestCommonAncestor方法采用递归的方式实现最小公共祖先的搜索。从根节点开始，逐层向下搜索，直到找到最小公共祖先或遇到空节点或其中一个节点。

我们通过创建一个示例二叉树来测试代码，其中展示了一个版本控制系统的版本历史。然后，我们使用Solution类的实例调用findLowestCommonAncestor方法，在示例二叉树中寻找节点C4和C5的最小公共祖先。

最后，我们打印出找到的最小公共祖先节点的哈希值，以验证代码的正确性。

这样，通过使用递归搜索二叉树，我们找到了两个提交节点的最小公共祖先，实现了git rebase算法中寻找最小公共祖先的核心逻辑。

——----————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

这段代码实现了一个函数 findLowestCommonAncestor，用于寻找两个提交节点在二叉树中的最小公共祖先。下面我们来解释代码的思路和执行过程。

假设我们有一棵二叉树，每个节点代表一个提交，其中根节点是整个提交历史的起点。每个提交节点都有一个唯一的哈希值，并且可以有左子节点和右子节点，表示其父节点指向的提交。

现在，我们的目标是找到两个特定提交节点 p1 和 p2 的最小公共祖先。这就像在提交历史中寻找两个提交的共同祖先，即它们最早的交汇点。

代码采用递归的方式实现了这个目标。我们从根节点开始，逐层向下搜索，直到找到最小公共祖先或者遇到空节点或者其中一个节点。

首先，我们检查当前节点是否为空或者等于 p1 或 p2。如果是，那么当前节点就是其中一个节点或最小公共祖先，我们直接返回该节点。

如果当前节点不是上述情况，我们递归调用函数分别在左子树和右子树中寻找 p1 和 p2 的最小公共祖先。这就像在左右分支中继续寻找这两个节点的最小公共祖先。

最后，我们根据左子树和右子树中找到的结果进行判断：

如果左右子树中都找到了非空节点，那么当前节点就是最小公共祖先，我们返回该节点。
如果只有一棵子树中找到了非空节点，那么说明最小公共祖先在那棵子树上，我们返回该节点。
通过不断递归调用，我们最终找到了 p1 和 p2 的最小公共祖先节点，并将其返回。

执行过程可以用以下比喻来理解：假设我们有一个家族谱系的家族树，每个节点代表一个家族成员，根节点代表家族的始祖。我们想找到两个人的共同祖先，就从根节点开始向下查找，直到找到他们的共同祖先或者其中一个人。通过递归调用，我们可以沿着家族树向下搜索，直到找到最小公共祖先节点。

总结起来，这段代码通过递归搜索二叉树，找到了两个提交节点的最小公共祖先节点，实现了git rebase算法中寻找最小公共祖先的核心逻辑。
