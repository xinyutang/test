可以使用动态规划的思想来解决这个问题。具体来说，可以设一个一维的列表dp，其中dp[i]表示和为i时对应的最大乘积。对于每个dp[i]，都可以考虑从哪些数转移而来，显然，对于任意一个正整数x，dp[i]可以由dp[i-x]*x得到，因此，可以遍历所有的正整数x，求出dp[i-x]*x的最大值，从而更新dp[i]。

下面是对应的Python代码实现：
def findBestSplit(n, m):
    # 初始化dp列表
    dp = [1] + [0] * m
    
    # 遍历所有可能的和值
    for i in range(1, m + 1):
        # 遍历所有可能的正整数x
        for x in range(1, n + 1):
            if i - x >= 0:
                dp[i] = max(dp[i], dp[i - x] * x)
                
    # 回溯得到每个数的数值
    res = []
    i = m
    while i > 0:
        for x in range(1, n + 1):
            if i - x >= 0 and dp[i] == dp[i - x] * x:
                res.append(x)
                i -= x
                break
                
    return res

# 示例测试
print(findBestSplit(2, 6)) # [3, 3]
这段代码的时间复杂度为$O(nm)$，空间复杂度为$O(m)$。



